## 請說明雜湊跟加密的差別在哪裡，為什麼密碼要雜湊過後才存入資料庫
- 加密是一個可逆的過程，可以透過解碼來得知原始的密碼。( 密碼跟產生的祕文是一對一的)
- 雜湊的特點是：這是一個沒辦法逆推的東西，由於不同長度的密碼在雜湊運算後都會跑出固定長度的輸出（不同的演算法會有不同的長度設定），又因此，無限多種密碼在運算後，需要在有限的位數內表示出來，代表一定會有不同的文字運算後會得到相同的結果，這種狀態被叫做＂碰撞＂（雖然一個好的演算法發生碰撞的機率很低），一方面也由於這個特性，我們沒辦法回推原文是甚麼。舉例來說:我們知道輸出的值是一個除以 200 餘數是 2 的東西，但我們並沒有辦法因此知道到底原本的東西到底是 2002? 2? 402? 。 

- 雜湊的運作方式：簡單來說就是對原始的密碼做一個複雜的運算，然後再把結果記錄下來，放進資料庫裏面，每次要進行比對的時候，就是把使用者輸入的密碼進行一次複雜的運算，比對結果是否相同，在這個情況下來說，Server 其實也不知道使用者真正的密碼到底是甚麼，只知道這個密碼運算過後會變成甚麼樣子。( 而因為雜湊的運算複雜度很高而且發生碰撞的機率滿小的，所以當運算過後的產物相同，理論上可以合理的當作輸入值就是正確的密碼。)

- 加鹽:
這是一種為了應付查表(建立一個表單，紀錄各種輸入值跟產出值，企圖找出原文密碼的方式)，而產生的方法。這個方法簡單來說就是:提供服務的人自動幫使用者的輸入值，在不特定的位置加上一些其他的字，然後再拿去湊砸運算，再把這個輸出值記錄下來。

如此一來，駭客就算查了表，但由於不知道鹽到底加在哪裡?加了甚麼?所以查表可以破解的機率又更低了。

- 至於為甚麼需要將密碼雜湊過後再存入資料庫的原因，最大的原因就是因其不可逆的特性，無法逆推回原來的輸入值。這樣就算資料庫真的被駭、資料外洩了，駭客也沒有辦法因此知道其原本的密碼(有可能有使用者在多個地方使用相同的密碼)。同樣的因素也可以讓 Server 的內部人員外洩資料的機會降到最低。

## `include`、`require`、`include_once`、`require_once` 的差別
- `require` : 通常是放在 php 檔案的最前面，一開始就載入，找不到檔案載入時，程式會停止並報錯，載入的東西不可用於迴圈。
- `include` : 也是拿來引入用的，但通常是用在程式碼內，動態使用比較多，可用於迴圈。找不到檔案載入時，會報錯但程式不會停止。

- `後綴_once` :基本上功能跟前兩項一樣，差別在於有後綴的可以避免重複引入，因此大多數的時間都建議要用有後綴的寫法。


## 請說明 SQL Injection 的攻擊原理以及防範方法

這個方法是透過 SQL 在輸入值的時候把應該是字串的地方理解成了 SQL 的程式碼，所形成的漏洞，這個地方可以使用 SQL 內建的指令( `$conn->perpare($SQL);` )來做跳脫，讓應該是字串的地方，以字串的形式被執行，即可解決這個漏洞。



##  請說明 XSS 的攻擊原理以及防範方法

簡單的來說就是有人透過在可以自定義輸入值的地方，輸入了讓伺服器以為是 java script 的內容，來偷偷取得本來取得不到的資料。
由於這個手法是建立在伺服器把應該要是字串的地方理解成了 java script 而產生的錯誤，所以只需要把來自 clien 端的資料都做字串跳脫，讓伺服器以字串的方式解讀就可以了。


## 請說明 CSRF 的攻擊原理以及防範方法
簡而言之應該是一種趁使用者不注意，以其名義發出 request 的攻擊。
怎麼個趁使用者不注意法呢? 其手法有點像是放在 MAIL 裡面用來知道是否開啟信件的透明圖片一樣，利用看不見的表單，透過其他的點擊操作讓使用者在非自願的情況送出 POST 或 JSON 格式的 request 。(這邊的狀況是:駭客會從不同 domain 發 request 到目標網頁，而使用者若是登入狀態的話，發到目標網頁的東西會自動帶上 Session ，所以就會被以為是使用者本人這樣。)


### 使用者防範方式
- 記得用完就登出。

### Server 端防範方式

- 上面提到的方法，因為 FORM 可以傳送的內容種類只有三種，其中這邊使用的是`text/plain`，因此 SERVER 如果有檢查這項，便可以抵擋這個攻擊。但這裡並不包含 API 若接受不同 origin 的 request 的情況。

*由於防禦 CSRF 攻擊的重點是:判斷究竟發出 request 的人是否是真的使用者本人。*

- 其中一個辨別辦法是判斷 request header 裡面的 Referer 欄位，如果不來自合法 domain 就不接受，但是缺點是
    1. 並非所有瀏覽器都會帶 referer。
    2. 使用者有可能會關閉自動帶 referer的功能。
    3. 若攻擊的人使用前綴和攻擊目標相同的網址就會造成漏洞
    比方說: 目標網站長這樣 `hihi.yoyoyoy.com`
    但發出攻擊的地方長這樣 `hihi.yoyoyoy.com.attack.com` 還是會被攻擊成功。

- 另外個方法是像網路銀行那樣，使用圖片認證或是簡訊認證之類的，這樣就非常的安全，但是如果其他諸如刪個發文也要這樣認證，使用者應該會覺得很煩。

因此我們需要一個像是間諜找同伴時得說出暗號一樣的東西，提供一個暗號給 server 端，讓他確認就是我們本人無誤。
- 在實務上我們會在 form 裡面用 hidden 多帶一個叫做 `csrtoken` 的東西，這東西由 server 端隨機產生，再儲存在 server 那邊。當收到 request 時 server 會去對比這是不是正確的 token 這樣。

    - ( `csrtoken` 這東西的運作原理跟 session 基本上差不多，只是放在這邊是一個雙重暗號的概念。比方說:魯夫一行人在阿拉巴斯坦王國遇到擁有易容術的能力者時，他們選擇在手臂上包繃帶(第一重)，而只有真正的夥伴才知道繃帶裡面應該還有個叉叉符號(第二重)，類似這樣的概念。)

    -  ( 請注意造成 session 漏洞的原因，並非運作機制被破解，主要問題在於我們的使用者平常都沒有登出 (session 是處於登入的狀態)，才讓這個跨 domain 的 request 有機可乘。而非 Session 的 token 被破壞或被猜出來了，因此使用雙重的 session 機制還是有意義的。)

但這個時候又會發現，若是 Server 接受 cross origin 的 request 的話，攻擊者還是可以從他那邊的 domain 發起攻擊，拿到 `csrtoken` ，再發出其他攻擊。

- 因此又想了另一個辦法，這邊主要是要區別到底發出 request 的人是否在同個 domain?
因此照著這個思路，我們想到，攻擊者並沒有辦法設定 session (除非伺服器直接被駭)，所以我們讓 clien 送出 request 時，在表單跟 header 都帶上相同內容的`csrtoken`，然後 server 收到的時候再比對者兩個東西有沒有相同，就可以分辨到底是否是使用者了!

不過這也有缺點，就像上面說的若被攻擊者掌握了某個 sub-domain 的話，他還是可以自己在那個 sub-domian 下發 session，還是會失效。


### 那麼瀏覽器端有甚麼防範方式呢 ~~~
- 現在 google 推出了一個 `SameSite` 的功能，把他加在 session 後面的話，就會讓這個session 只能在同一個 site 裡面使用。不管是`<a> <from> 還是 <XTMLrequest>`只要發出的 request 不在同個 site 的範圍內，都不會帶 session 了，是不是超激安全!

但是這衍生一個問題 : 如果我從這個網站點一個`<a>`出去的時候，因為不帶 session 了，就會變成登出狀態，使用者體驗會非常糟。

- 因此誕生了另外種模式`Lax`。例如說`<a>, <link rel="prerender">, <form method="GET">`這些都還是會帶上 cookie。但是 POST 方法 的 form，或是只要是 POST, PUT, DELETE 這些方法，就不會帶上 cookie。*所以要注意這個模式不能防範 POST 型態的 CSRF 喔~~*


